using System;
using System.Collections;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MinimalApiDiscoveryGenerator;

[Generator]
public class MapApiGenerator : IIncrementalGenerator 
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    var apiClasses = context.SyntaxProvider
      .CreateSyntaxProvider(predicate: static (s, _) => IsTarget(s),
        transform: static (ctx, _) => GetTarget(ctx))
      .Where(static m => m is not null);

    var compilation = context.CompilationProvider.Combine(apiClasses.Collect());

    context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(source.Left, source.Right, spc));

  }

  static void Execute(Compilation compilation, 
    ImmutableArray<TypeDeclarationSyntax> typeList, 
    SourceProductionContext context)
  {
    if (typeList.IsDefaultOrEmpty)
    {
      // nothing to do yet
      return;
    }

   
    if (typeList.Count() > 0)
    {

      // stop if we're asked to
      context.CancellationToken.ThrowIfCancellationRequested();

      var sb = new StringBuilder();

      // TODO, test with multiple projects
      sb.Append($@"// <auto-generated/>
using System;
using Microsoft.AspNetCore.Builder;

namespace WilderMinds.MinimalApiDiscovery
{{
  public static class MinimalApiDiscoveryGeneratedExtensions
  {{
    public static WebApplication MapApis(this WebApplication app)
    {{
      // Call Register on all classes that implement IApi");

      foreach (var api in typeList)
      {
        SemanticModel semanticModel = compilation.GetSemanticModel(api.SyntaxTree);
        if (semanticModel.GetDeclaredSymbol(api) is not INamedTypeSymbol apiSymbol)
        {
          // something went wrong, bail out
          continue;
        }

        // Test for abstract and that some
        if (!apiSymbol.IsAbstract)
        {
          var apiClassName = apiSymbol.ToString();
          if (!apiSymbol.Constructors.Any(c => c.Parameters.Count() == 0))
          {
            // Write error out if no constructors have zero parameters
            context.ReportDiagnostic(Diagnostic.Create(
                  new DiagnosticDescriptor(
                      "SG0001",
                      "Api Classes should have an empty constructor",
                      "Cannot register {0} class without an empty constructor. Using state {0} class's constructor will create an unintentional singleton",
                      "Problem",
                      DiagnosticSeverity.Warning,
                      true),
                  apiSymbol.Locations.FirstOrDefault(),
                  apiSymbol.ToDisplayString()));
          }
          else
          {
            sb.Append($@"
      new global::{apiClassName}().Register(app);");

          }
        }
      }

      sb.Append(@$"
      return app;
    }}
  }}
}}");

      var theCode = sb.ToString();
      context.AddSource("MinimalApiDiscovery.g.cs", SourceText.From(theCode, Encoding.UTF8));
    }
  }

  static TypeDeclarationSyntax GetTarget(GeneratorSyntaxContext ctx)
  {
    var theClass = (ClassDeclarationSyntax)ctx.Node;

    var classSymbol = ctx.SemanticModel.GetDeclaredSymbol(theClass);
    if (classSymbol.AllInterfaces.Count() > 0)
    {
      // Get all interfaces (class and subclasses)
      foreach (var  symbol in classSymbol.AllInterfaces)
      {
        if (symbol.ToDisplayString().Contains("IApi"))
        {
          return theClass;
        }
      }
    }

    return null;
  }

  static bool IsTarget(SyntaxNode node) => node is ClassDeclarationSyntax;


}
