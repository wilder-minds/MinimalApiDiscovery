using System;
using System.Collections;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MinimalApiDiscoveryGenerator;

[Generator]
public class MapApiGenerator : IIncrementalGenerator
{
  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    var apiClasses = context.SyntaxProvider
      .CreateSyntaxProvider(predicate: static (s, _) => IsTarget(s),
        transform: (n, cn) => GetTarget(n, cn))
      .Where(static m => m.Valid);

    context.RegisterSourceOutput(apiClasses.Collect(), Execute);

  }

  static void Execute(SourceProductionContext context, ImmutableArray<(string Name, bool Warn, bool Valid)> typeList)
  {
    if (typeList.IsDefaultOrEmpty)
    {
      // nothing to do yet
      return;
    }


    if (typeList.Count() > 0)
    {

      // stop if we're asked to
      context.CancellationToken.ThrowIfCancellationRequested();

      var sb = new StringBuilder();

      // TODO, test with multiple projects
      sb.Append($@"// <auto-generated/>
using System;
using Microsoft.AspNetCore.Builder;

namespace WilderMinds.MinimalApiDiscovery
{{
  public static class MinimalApiDiscoveryGeneratedExtensions
  {{
    public static WebApplication MapApis(this WebApplication app)
    {{
      // Call Register on all classes that implement IApi");

      foreach (var api in typeList)
      {
        if (api.Warn)
        {
          // Write error out if no constructors have zero parameters
          context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "SG0001",
                    "Api Classes should have an empty constructor",
                    "Cannot register {0} class without an empty constructor. Using state {0} class's constructor will create an unintentional singleton",
                    "Problem",
                    DiagnosticSeverity.Warning,
                    true),
                Location.None,
                api.Name));
        }
        else
        {
          sb.Append($@"
      new global::{api.Name}().Register(app);");

        }
      }

      sb.Append(@$"
      return app;
    }}
  }}
}}");

      var theCode = sb.ToString();
      context.AddSource("MinimalApiDiscovery.g.cs", SourceText.From(theCode, Encoding.UTF8));
    }
  }

  static void Debug()
  {
    if (!Debugger.IsAttached) Debugger.Launch();
  }

  static (string Name, bool Warn, bool Valid) GetTarget(GeneratorSyntaxContext ctx, CancellationToken cn)
  {
    var syntax = (ClassDeclarationSyntax)ctx.Node;
    var symbol = ctx.SemanticModel.GetDeclaredSymbol(syntax, cn);

    if (!symbol.IsAbstract)
    {
      if (symbol.AllInterfaces.Count() > 0)
      {
        // Get all interfaces (class and subclasses)
        foreach (var iSymbol in symbol.AllInterfaces)
        {
          if (iSymbol.ToDisplayString().EndsWith("IApi"))
          {
            return (
              Name: symbol.ToDisplayString(),
              Warn: !(symbol.Constructors.Any(c => c.Parameters.Count() == 0)),
              Valid: true);
          }
        }
      }
    }

    return (Name: "", Warn: false, Valid: false);
  }

  static bool IsTarget(SyntaxNode node) => node is ClassDeclarationSyntax;

}
